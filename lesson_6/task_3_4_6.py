# Определить, какое число в массиве встречается чаще всего.
from random import randint
from sys import getsizeof

list_1 = [randint(1, 5) for _ in range(20)]

print(list_1)
max_count = 0
max_count_els = []
for idx in range(len(list_1)):
    count = list_1.count(list_1[idx])
    if count > max_count:
        max_count = count
        max_count_els.clear()
        max_count_els.append(list_1[idx])
    elif count == max_count and (list_1[idx] not in max_count_els):
        max_count_els.append(list_1[idx])

numbers_str = ', '.join(map(str, max_count_els))
print(f'Максимальное количество вхождений одного числа: {max_count}\n'
      f'Числа, которые встречаются в массиве максимальное количество раз: {numbers_str}')
# Посчитаем объем памяти, выделенный под переменные в данной программе вручную, операясь на данные таблицы из методички.
# Переменная list_1 содержит 20 целых чисел. Одно целое число занимает в памяти 24 байта. Объём памяти, занимаемый
# списком рассчитывается по формуле 40 + 8 * длина списка. Соответственно, объем памяти, выделенный под список
# list_1 должен рассчитываться по формуле:
# 24 * 20 + (40 + 8 * 20) = 680 B = 0,68 kB
# Переменные max_count, count и idx содержат целые числа и займут в памяти по 24 байта.
# В переменную max_count_els сохраняются элементы массива list_1, которые встречаются в list_1 максимальное количество
# раз. Подсчитать теоретический объем занимаемой ей памяти не представляется возможным, поскольку при каждом новом
# запуске данной программы генерируются новые случайные исходные данные.
# Вычислим объемы памяти, выделенный под переменные list_1, max_count, max_count_els средствами Python:
list_1_size = getsizeof(list_1[0]) * len(list_1) + getsizeof(list_1)
max_count_size = getsizeof(max_count)
max_count_els_size = getsizeof(max_count_els[0]) * len(max_count_els) + getsizeof(max_count_els)
print(f'Объем памяти, занимаемый переменной list_1: {list_1_size} B')
print(f'Объем памяти, занимаемый переменной max_count: {max_count_size} B')
print(f'Объем памяти, занимаемый переменной max_count_els: {max_count_els_size} B')
# Результат расчёта средствами Python показал, что переменная list_1 заняла больше памяти, чем ожидалось.
# Так получилось потому, что типом данных для переменной list_1 является list comprehension, а не обычный список list.
# Тип данных list comprehension даёт выигрыш в скорости выполнения программы, но способствует большему расходу памяти.
# Данная задача не подразумевает внесение изменений в исходные данные, а также использование в качестве исходных данных
# массива случайных чисел, поэтому в качестве исходных данных мы вполне могли бы использовать кортеж с целью экономии
# памяти.
# Результат вычисления объема памяти, занимаемого переменной max_count практически совпал с теоретическим расчётом.
# В переменную max_count_els сохраняются динамические даные, получаемые в процессе работы программы. Для данной
# переменной могли бы использовать тип данных set. Но использование такого типа данных привело бы к повышению расхода
# памяти.
# Таким образом получается, что конкретно в данной задаче память используется недостаточно эффективно из-за
# использования типа данных list comprehension в качестве массива исходных данных.
